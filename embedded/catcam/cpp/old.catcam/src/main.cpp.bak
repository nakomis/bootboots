/*
 * PCF8574 + Camera + SD Test Program
 * Comprehensive test to validate:
 * 1. I2C communication with PCF8574 using UART0 pins
 * 2. ESP32-CAM camera functionality
 * 3. SD card saving capability
 * 
 * Hardware setup:
 * - ESP32-CAM with SD card inserted
 * - PCF8574 I2C GPIO expander
 * - LED connected to PCF8574 P0 (with appropriate resistor)
 * - I2C connections: SDA=GPIO1 (UART0 TX), SCL=GPIO3 (UART0 RX)
 * - Pull-up resistors on SDA/SCL lines (4.7kÎ© recommended)
 * 
 * Note: Disconnect UART0 pins during flashing, reconnect for testing
 */

#include <Arduino.h>
#include <Wire.h>
#include <esp_camera.h>
#include <SD_MMC.h>
#include <FS.h>

// Use Serial1 for debugging output (UART1, pins 9/10)
#define SerialDebug Serial1

// Pin definitions for new architecture
#define I2C_SDA_PIN GPIO_NUM_1         // UART0 TX for I2C SDA
#define I2C_SCL_PIN GPIO_NUM_3         // UART0 RX for I2C SCL
#define STATUS_LED_PIN GPIO_NUM_33     // Built-in red LED
#define TEST_LED_PIN 0                // PCF8574 pin for testing (e.g., LED)

// LED status codes
#define STATUS_OK 1
#define STATUS_I2C_ERROR 2
#define STATUS_CAM_ERROR 3
#define STATUS_SD_ERROR 4

// LED blink patterns (in milliseconds)
#define BLINK_SHORT 100
#define BLINK_LONG 300
#define BLINK_PAUSE 300

// Camera pin definitions (ESP32-CAM standard)
#define PWDN_GPIO_NUM 32
#define RESET_GPIO_NUM -1
#define XCLK_GPIO_NUM 0
#define SIOD_GPIO_NUM 26
#define SIOC_GPIO_NUM 27
#define Y9_GPIO_NUM 35
#define Y8_GPIO_NUM 34
#define Y7_GPIO_NUM 39
#define Y6_GPIO_NUM 36
#define Y5_GPIO_NUM 21
#define Y4_GPIO_NUM 19
#define Y3_GPIO_NUM 18
#define Y2_GPIO_NUM 5
#define VSYNC_GPIO_NUM 25
#define HREF_GPIO_NUM 23
#define PCLK_GPIO_NUM 22

// PCF8574 configuration
#define PCF8574_ADDRESS 0x20           // Default I2C address
#define TEST_LED_PIN 0                 // P0 on PCF8574

// Test parameters
#define BLINK_INTERVAL_MS 500          // LED blink rate
#define PHOTO_INTERVAL_MS 5000         // Take photo every 5 seconds
#define I2C_CLOCK_SPEED 100000         // 100kHz for reliability

// System status
bool pcf8574_available = false;
bool camera_available = false;
bool sd_available = false;
int photo_count = 0;

// Timing variables
unsigned long last_blink = 0;
unsigned long last_photo = 0;
bool led_state = false;

// Function implementations
bool initCamera() {
    camera_config_t config;
    
    config.ledc_channel = LEDC_CHANNEL_0;
    config.ledc_timer = LEDC_TIMER_0;
    config.pin_d0 = Y2_GPIO_NUM;
    config.pin_d1 = Y3_GPIO_NUM;
    config.pin_d2 = Y4_GPIO_NUM;
    config.pin_d3 = Y5_GPIO_NUM;
    config.pin_d4 = Y6_GPIO_NUM;
    config.pin_d5 = Y7_GPIO_NUM;
    config.pin_d6 = Y8_GPIO_NUM;
    config.pin_d7 = Y9_GPIO_NUM;
    config.pin_xclk = XCLK_GPIO_NUM;
    config.pin_pclk = PCLK_GPIO_NUM;
    config.pin_vsync = VSYNC_GPIO_NUM;
    config.pin_href = HREF_GPIO_NUM;
    // Use non-deprecated SCCB pin names
    config.pin_sccb_sda = SIOD_GPIO_NUM;
    config.pin_sccb_scl = SIOC_GPIO_NUM;
    config.pin_pwdn = PWDN_GPIO_NUM;
    config.pin_reset = RESET_GPIO_NUM;
    config.xclk_freq_hz = 20000000;
    config.pixel_format = PIXFORMAT_JPEG;
    
    // If PSRAM is available, use it for the frame buffer
    if(psramFound()) {
        config.frame_size = FRAMESIZE_UXGA;
        config.jpeg_quality = 10;
        config.fb_count = 2;
    } else {
        config.frame_size = FRAMESIZE_SVGA;
        config.jpeg_quality = 12;
        config.fb_count = 1;
    }

    // Camera init
    esp_err_t err = esp_camera_init(&config);
    if (err != ESP_OK) {
        SerialDebug.printf("Camera init failed with error 0x%x", err);
        return false;
    }
    
    sensor_t *s = esp_camera_sensor_get();
    // Set camera parameters if needed
    // s->set_...(s, ...);
    
    return true;
}

bool initSDCard() {
    if(!SD_MMC.begin()) {
        SerialDebug.println("SD Card Mount Failed");
        return false;
    }
    
    uint8_t cardType = SD_MMC.cardType();
    if(cardType == CARD_NONE) {
        SerialDebug.println("No SD Card attached");
        return false;
    }
    
    SerialDebug.print("SD Card Type: ");
    if(cardType == CARD_MMC) {
        SerialDebug.println("MMC");
    } else if(cardType == CARD_SD) {
        SerialDebug.println("SDSC");
    } else if(cardType == CARD_SDHC) {
        SerialDebug.println("SDHC");
    } else {
        SerialDebug.println("UNKNOWN");
    }
    
    uint64_t cardSize = SD_MMC.cardSize() / (1024 * 1024);
    SerialDebug.printf("SD Card Size: %lluMB\n", cardSize);
    
    return true;
}

bool captureAndSavePhoto() {
    // Take a photo
    camera_fb_t *fb = esp_camera_fb_get();
    if(!fb) {
        SerialDebug.println("Camera capture failed");
        return false;
    }
    
    // Create a filename with incrementing number
    char filename[32];
    sprintf(filename, "/photo_%d.jpg", photo_count++);
    
    // Save the file
    File file = SD_MMC.open(filename, FILE_WRITE);
    if(!file) {
        SerialDebug.println("Failed to create file");
        esp_camera_fb_return(fb);
        return false;
    }
    
    file.write(fb->buf, fb->len);
    file.close();
    
    // Return the frame buffer back to the driver for reuse
    esp_camera_fb_return(fb);
    
    SerialDebug.printf("Photo saved as %s\n", filename);
    return true;
}

bool writePCF8574(uint8_t data) {
    Wire.beginTransmission(PCF8574_ADDRESS);
    Wire.write(data);
    uint8_t error = Wire.endTransmission();
    return (error == 0);
}

void blinkStatusLED(int count, int blink_duration) {
    for (int i = 0; i < count; i++) {
        digitalWrite(STATUS_LED_PIN, LOW);  // LED ON (active low)
        delay(blink_duration);
        digitalWrite(STATUS_LED_PIN, HIGH); // LED OFF
        if (i < count - 1) delay(BLINK_PAUSE);
    }
}

void indicateStatus(int status) {
    // Flash the status LED to indicate system status
    switch(status) {
        case STATUS_OK:
            // 1 short blink - System OK
            blinkStatusLED(1, BLINK_SHORT);
            break;
        case STATUS_I2C_ERROR:
            // 2 short blinks - I2C error
            blinkStatusLED(2, BLINK_SHORT);
            break;
        case STATUS_CAM_ERROR:
            // 3 short blinks - Camera error
            blinkStatusLED(3, BLINK_SHORT);
            break;
        case STATUS_SD_ERROR:
            // 4 short blinks - SD card error
            blinkStatusLED(4, BLINK_SHORT);
            break;
        default:
            // Long blink - Unknown error
            blinkStatusLED(1, BLINK_LONG);
    }
}

uint8_t readPCF8574() {
    uint8_t data = 0;
    // Use explicit type casting to resolve ambiguity
    uint8_t bytes_received = Wire.requestFrom((uint8_t)PCF8574_ADDRESS, (uint8_t)1);
    
    if (bytes_received == 1) {
        data = Wire.read();
        return data;
    } else {
        SerialDebug.println("I2C read failed");
        return 0xFF; // Error value
    }
}

void setup() {
    // Initialize built-in status LED (active LOW - LED ON when pin is LOW)
    pinMode(STATUS_LED_PIN, OUTPUT);
    digitalWrite(STATUS_LED_PIN, HIGH); // Turn LED OFF initially
    delay(1000);
    
    // Flash LED 3 times to show startup
    for (int i = 0; i < 3; i++) {
        digitalWrite(STATUS_LED_PIN, LOW);  // LED ON
        delay(100);
        digitalWrite(STATUS_LED_PIN, HIGH); // LED OFF
        delay(100);
    }
    
    // Leave LED ON to show we entered setup
    digitalWrite(STATUS_LED_PIN, LOW);
    delay(500);
    digitalWrite(STATUS_LED_PIN, HIGH);
    delay(500);
    
    // === 1. TEST I2C AND PCF8574 ===
    // Flash twice before I2C init
    for (int i = 0; i < 2; i++) {
        digitalWrite(STATUS_LED_PIN, LOW);
        delay(200);
        digitalWrite(STATUS_LED_PIN, HIGH);
        delay(200);
    }
    
    Wire.begin(I2C_SDA_PIN, I2C_SCL_PIN);
    Wire.setClock(I2C_CLOCK_SPEED);
    
    // Flash 3 times before I2C test
    for (int i = 0; i < 3; i++) {
        digitalWrite(STATUS_LED_PIN, LOW);
        delay(100);
        digitalWrite(STATUS_LED_PIN, HIGH);
        delay(100);
    }
    
    // Test I2C communication with PCF8574
    Wire.beginTransmission(PCF8574_ADDRESS);
    uint8_t error = Wire.endTransmission();
    
    // Flash 4 times if I2C error, 1 long flash if success
    if (error != 0) {
        for (int i = 0; i < 4; i++) {
            digitalWrite(STATUS_LED_PIN, LOW);
            delay(200);
            digitalWrite(STATUS_LED_PIN, HIGH);
            delay(200);
        }
        pcf8574_available = false;
    } else {
        digitalWrite(STATUS_LED_PIN, LOW);
        delay(500);
        digitalWrite(STATUS_LED_PIN, HIGH);
        pcf8574_available = true;
        if (!writePCF8574(0x00)) {
            pcf8574_available = false;
        }
    }
    
    // === 2. TEST CAMERA ===
    camera_available = initCamera();
    if (!camera_available) {
        indicateStatus(STATUS_CAM_ERROR);
    }
    
    // === 3. TEST SD CARD ===
    sd_available = initSDCard();
    if (!sd_available) {
        indicateStatus(STATUS_SD_ERROR);
    }
    
    // Indicate I2C status if there was an error
    if (!pcf8574_available) {
        indicateStatus(STATUS_I2C_ERROR);
    } else if (camera_available && sd_available) {
        // All systems go!
        indicateStatus(STATUS_OK);
    }
    
    if (pcf8574_available) {
        SerialDebug.println("PCF8574 LED will blink every 500ms");
    }
    if (camera_available && sd_available) {
        SerialDebug.println("Photos will be captured every 5 seconds and saved to SD");
    }
    
    SerialDebug.println("=== STARTING CONTINUOUS TEST ===");
}

void loop() {
    static unsigned long last_led_toggle = 0;
    static bool led_state = false;
    static unsigned long last_photo = 0;
    static unsigned long last_status_indication = 0;
    static bool status_shown = false;
    
    unsigned long current_time = millis();
    
    // Show system status via LED every 10 seconds
    if (current_time - last_status_indication >= 10000) {
        last_status_indication = current_time;
        status_shown = false;
    }
    
    // Toggle LED every 500ms if PCF8574 is available
    if (current_time - last_led_toggle >= 500) {
        last_led_toggle = current_time;
        led_state = !led_state;
        
        if (pcf8574_available) {
            uint8_t pcf_state = led_state ? (1 << TEST_LED_PIN) : 0x00;
            writePCF8574(pcf_state);
        }
    }
    
    // Show system status if not already shown in this cycle
    if (!status_shown && (current_time - last_status_indication) > 1000) {
        if (!pcf8574_available) {
            indicateStatus(STATUS_I2C_ERROR);
        } else if (!camera_available) {
            indicateStatus(STATUS_CAM_ERROR);
        } else if (!sd_available) {
            indicateStatus(STATUS_SD_ERROR);
        } else {
            indicateStatus(STATUS_OK);
        }
        status_shown = true;
    }
    
    // Take photo every 5 seconds if both camera and SD card are available
    if (camera_available && sd_available) {
        if (current_time - last_photo >= 5000) {
            last_photo = current_time;
            captureAndSavePhoto();
        }
    }
    
    delay(10); // Small delay to prevent overwhelming the loop
}
